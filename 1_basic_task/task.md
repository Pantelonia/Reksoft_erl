## Блок "Общий обзор языка"
#### 1.1. Простые выражения. Введите в оболочку Erlang следующие выражения и объясните результат.

 - `B = 1.`
 - `1 = B.`
 - `1 = C.`
 - `C = 1.`
 - `C = B.`
 - `A = F = D = B.` (Что в данном случае происходит с переменными A, F, D при
   наличи уже связанной переменной B?)


#### Решение:
```
1. Оболочка вывела 1, продемонстрировав результат связывания значение 1 с несвязанной переменной B
2. Оболочка вывела 1. Значение связанной переменной B была сравнена с 1, они совпали и было выведено значение 1
3. Выведет ошибку. Так как С - несвязанная переменная и не имеет значение
4. Оболочка вывела 1, продемонстрировав результат связывания значение 1 с несвязанной переменной B
5. Оболочка вывела 1. Переменная B сравнили с переменной C, значение совпали и было выведено их значение.
6. Оболочка вывела 1.Всем несвязанным переменным слева от B было присвоено значение справа значение связанной переменной равное 1
```
-------------
#### 1.2. Сопоставление с образцом.

 - Объясните, почему выражение `Path = "/bar/foo", Bar ++ "/foo" = Path` не
   может быть вычислено интерпретатором и порождает ошибку?
 - А сработает ли следующее выражение: `"/bar/" ++ Foo = Path.`? Что является
   его результатом?
 - Каков результат следующего выражения?

```erlang
Person = #{name => "Mike", surname => "Williams", phone  => [1,2,3,4]}.
#{
    name := Name,
    surname := Name,
    phone := Phone
} = Person.
```
1. 
2. Сработает.В результате выведется значение Path, а переменной Foo записалось значение "foo"
3. Выведет ошибку `exception error: no match of right hand side value`. Так как переменной Namе  присвоивается значение дважды.
---------
#### 1.3.Сравнение
```
На всех типах данных определены операции сравнения, такие как больше (`>`),
меньше (`<`), меньше или равно (`=<`), больше или равно (`>=`), нестрогое
равенство (`==`), строгое равенство (`=:=`), неравенство (`=/=`). Повводите в
интерпретатор различные варианты сравнений и попытайтесь понять, по каким
правилам сравниваются те или иные термы. Например:

 - `atom1 > atom2.`
 - `atom10 < atom2.`
 - `#{a => 0} < #{a => 1}.`
 - `#{a => 1} < #{a => 0, b => 0}.`
 - `{a, 1, 0} > {a, 0, 0}`.

Объясните результат каждого сравнения. Попробуйте сравнить между собой термы
разных типов.
```
#### Решение
>Важен не сам порядок, а что порядок четко определен
>Joe Armstrong
```erlang
12> atom1 > atom2.
false
13> atom10 < atom2.
true
14> #{a => 0} < #{a => 1}.
true
15> #{a => 1} < #{a => 0, b => 0}.
true
16> {a, 1, 0} > {a, 0, 0}.
true
```
В Erlang строго определен порядок сравнения
`number < atom < reference < fun < port < pid < tuple < list < bit string`
Атомы и списки сравниваются лексикографически,а кортежи сравниваются сначала по размеру. Если размеры равны, то сравнивают уже по правилу сравнения типов, который указан выше

-----
#### 1.4. Atoms, erlang shell

 - Какие атомы нельзя использовать?
 - В чем отличие строго равенства от нестрогого?
 - Как заставить интерпретатор "забыть" значение какой-либо переменной? А как
   заставить "забыть" все связывания?
#### Решение
1. В Erlang существуют зарезервированные атомы, которым нельзя задать значение: 
`after and andalso band begin bnot bor bsl bsr bxor case catch cond div end fun if let not of or orelse query receive rem try when xor`
Но! Если взять эти атомы в кавычки, то все сработает 
2. `== и /=` используются для сравнения чисел с плавающей запятой отцелых чисел
3. -f(). "Забыть" все переменные
   -f(%name%) "Забыть" переменную с именем %name%

-----

#### 1.5. Lists/binary comprehensions

 - Напишите LC, который выдаст декартово умножение двух списков.
 `[{X, Y} || X <- [1,2,3,4], Y <- [5,6,7,8]].`
 - Имеется список вида - [[1,2,3], [4,5,6], [7,8,9]]. С помощью какого LC мы
   можем получить плоский список?
 `[X||Y<-[[1,2,3], [4,5,6], [7,8,9]], X<-Y].`
 - Имеется список словарей вида:

```erlang
Dicts = [
    #{
        tags => [awesome, erlang],
    },
    #{
        tags => [simple_tag]
    },
    #{
        tags => [just_atom, 'I am ok']
    }
]
```
Какой list comprehension выдаст список вида: `[awesome, erlang, simple_tag,
just_atom, 'I am ok']` ?.

#### Решение
`[X|| #{tags := Y} <- Dicts, X<-Y].`

 - Имеется следующий список:

```erlang
MixedList = [
    john,
    doe,
    {age, 19},
    {height, 182},
    {weight, 72},
    london,
    britain
].
```
 - С помощью какого LC можно получить список вида? (см. ниже):
```erlang
 [
    {age, 19},
    {height, 182},
    {weight, 72}
 ]
 ```
 #### Решение
 ` [{Stat,Value}|| {Stat,Value}<- MixedList].`
 
 - Какой LC выдаст список, в котором только атомы `[john, doe, london, britain]`
   ?
   `[ X || X <- MixedList, is_atom(X) ].`
   
 
